/*
 * CSV.java
 *
 * Copyright (c) 2011 Janitza electronics GmbH
 */
package csv;

import de.janitza.pasw.database.DeviceInformation;
import de.janitza.pasw.database.IDBDeviceManager;
import de.janitza.pasw.database.devices.DeviceFilter;
import de.janitza.pasw.database.devices.DeviceFilterHelper;
import de.janitza.pasw.database.featurecore.IFeatureProvider;
import de.janitza.pasw.database.services.polling.PollingTimeContainerBaseImpl;
import de.janitza.pasw.device.core.api.IDevice;
import de.janitza.pasw.device.core.api.IDeviceCreator;
import de.janitza.pasw.device.core.api.IDeviceManager;
import de.janitza.pasw.device.core.api.connectiontype.IConnectionType;
import de.janitza.pasw.device.core.api.marker.IFictionalDevice;
import de.janitza.pasw.device.core.api.marker.IIsAutoGeneratedIDevice;
import de.janitza.pasw.device.core.connection.api.connectiontype.ConnectionTypes;
import de.janitza.pasw.device.core.connection.api.connectiontype.IConnectionTypeNone;
import de.janitza.pasw.device.core.service.api.services.polling.IPollingTimeContainer;
import de.janitza.pasw.device.core.service.api.services.polling.PollingItem;
// IntelliJ marks the package as unused, but it is needed for parsing Genmodbus
// profiles in xml format
import de.janitza.pasw.genericmodbus.xml.Xmlmodbustemplate;
import de.janitza.pasw.device.genericmodbus.tools.ModbusTemplateConfig;
import de.janitza.pasw.license.core.api.exception.NotLicensedException;
import java.nio.charset.StandardCharsets;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import org.netbeans.api.project.Project;
import org.openide.util.lookup.Lookups;

import com.aspose.cells.*;

/**
 *
 * @author andreas.kraft
 */
public final class CSV {

    private static final String CSV_SEPARATOR_FORIMPORT = ";";

    private static final Logger LOGGER = Logger.getLogger(CSV.class.getName());

    private static final int DEVTYPE_ROW = 0;
    private static final int CONNTYPE_ROW = 1;
    private static final int CONN_ROW = 2;
    private static final int DEVNAME_ROW = 3;
    private static final int DEVDESC_ROW = 4;
    private static final int TIMEPLAN_ROW = 5;
    private static final int POLLTIME_ROW = 6;
    private static final int MODBUS_TEMPLATE_ROW = 7;

    /**
     * Creates a new instance of CSV
     */
    private CSV() {
    }

    private static boolean isDeviceToIgnore(final IDevice device) {
        return device.getLookup().lookup(IIsAutoGeneratedIDevice.class) != null;
    }

    /**
     * Importiert in Project Geraeteliste aus Datei
     *
     * @param importParameters Contsains settings for import as source file, target project, ..
     * @param dryRun wenn false wird nur Liste ueberprueft
     * @param importInfo - get info about imported or skipped devices
     * @param devicelist list with imported devices
     * @param existdevices list with devices already existing in project
     * @throws IOException
     * @throws NotLicensedException
     */
    public static void importDevices(final IDeviceListImportParameters importParameters,
                                     final boolean dryRun,
                                     final ImportInformation importInfo,
                                     final List<IDeviceManager.AddDeviceHelper> devicelist,
                                     final List<IDeviceManager.AddDeviceHelper> existdevices)
            throws IOException, NotLicensedException {

        final Project project = importParameters.getProject();
        final File loadFile = importParameters.getImportFile();
        final IFeatureProvider projFeature =
                project.getLookup().lookup(IFeatureProvider.class);
        final IDBDeviceManager devMgr =
                project.getLookup().lookup(IDBDeviceManager.class);
        final DeviceCreatorMap convertMap = DeviceCreatorMap.getInstance();

        final DeviceInserter devInserter = new DeviceInserter(devicelist, existdevices,
                devMgr,
                importInfo, projFeature);

        final ModbusTemplateConfig modbusTemplate = project.getLookup().lookup(ModbusTemplateConfig.class);
        final HashMap<IDevice, String> templateMap = new HashMap<>(1);


        /// ASPOSE solution
        TxtLoadOptions opts = new TxtLoadOptions(LoadFormat.CSV);
        opts.setSeparator(CSV_SEPARATOR_FORIMPORT.charAt(0));

        opts.setEncoding(Encoding.getEncoding(StandardCharsets.UTF_8));
        try {
            String toload = loadFile.getAbsolutePath();
            Workbook wb = new Workbook(toload, opts);

            Worksheet ws = wb.getWorksheets().get(0);
            Cells cells = ws.getCells();


            final int maxColumns = cells.getMaxDataColumn();

            for (int rowCount = 0; rowCount <= cells.getMaxDataRow(); rowCount++) {
                for (int colCount = 0; colCount <= maxColumns; colCount++) {
                    final Cell cell = cells.get(rowCount, colCount);
                    final String trimmed = cell.getStringValue().trim();
                    cell.putValue(trimmed);
                }
            }


            RowCollection rows = cells.getRows();

            final Stream<Row> stream = StreamSupport.stream(rows.spliterator(), false);
            stream.each {  row ->
                final String firstCharStr = row.get(0).getStringValue();

                if (!firstCharStr.equals("#")) {
                    processLine(row,
                            devInserter,
                            convertMap,
                            dryRun,
                            importParameters.hasToSetTimeplanForAutoSync(),
                            modbusTemplate,
                            templateMap);
                }
            };
            importInfo.setNumberImportedDevices(devicelist.size());

            if (!dryRun) {
                devMgr.addDevices(devicelist);
                for (final IDeviceManager.AddDeviceHelper helper : devicelist) {
                    final IDevice dummyDevice = helper.getDevice();
                    final IPollingTimeContainer pollTimeContainerDummyDevice =
                            dummyDevice.getLookup().lookup(IPollingTimeContainer.class);
                    final IDevice device = helper.getCreatedDevice();
                    final IPollingTimeContainer pollTimeContainer =
                            device.getLookup().lookup(IPollingTimeContainer.class);
                    pollTimeContainer.copySettingsFrom(pollTimeContainerDummyDevice);

                    if (templateMap.containsKey(dummyDevice)) {
                        templateMap.put(device, templateMap.get(dummyDevice));
                    }
                }


                // Assign Modbusprofiles to all devices in the device Manager
                devMgr.getDevices().stream()
                        .filter{devInfo -> !(DeviceFilterHelper.filterByUniqueName(DeviceFilter.GENERIC_MODBUS, devInfo))}
                        .each{devInfo ->
                            modbusTemplate.getModbusTemplates().stream()
                                    .filter{template -> templateMap.containsKey(devInfo.getDevice())}
                                    .filter{template -> templateMap.get(devInfo.getDevice())
                                            .equals(template.getName())}
                                    .findAny()
                                    .ifPresent{template ->
                                        try {
                                            modbusTemplate.setDeviceTemplate(devInfo, template);
                                        } catch (IOException e) {
                                            LOGGER.log(Level.INFO, String.format("Could not assign Modbusprofile %s to %s", template.getName(), devInfo.getDisplayName()), e);
                                        }
                                    };
                        };
            }
        } catch (Exception e) {
            LOGGER.log(Level.WARNING, String.format("Could not load file %s", loadFile), e);
        }
    }

    private static void processLine(final Row row,
                                    final DeviceInserter devInserter,
                                    final DeviceCreatorMap convertMap,
                                    final boolean dryRun,
                                    final boolean setTimeplanForAutoSync,
                                    ModbusTemplateConfig modbusTemplateConfig,
                                    HashMap<IDevice, String> templateMap) {


            final String devType = DeviceTypeConverter.convertCSVToPASW(row.get(DEVTYPE_ROW).getDisplayStringValue());
            if (devType == null) {
                LOGGER.log(Level.WARNING, "Project.DevicePluginNotFound");
            } else {
                final IDeviceCreator devCreator =
                        DeviceCreatorMap.getInstance().getDeviceCreatorByInternalType(devType);
                final IDevice device = devCreator.createDevice(Lookups.fixed(
                        IFictionalDevice.createNew(),
                        new PollingTimeContainerBaseImpl()));
                final boolean isDeviceToIgnore = isDeviceToIgnore(device);
                if (isDeviceToIgnore) {
                    LOGGER.log(Level.WARNING, "Project.ImportNotAllowed");
                } else if (convertMap.getDeviceCreatorByInternalType(devType) == null) {
                    LOGGER.log(Level.WARNING, "Project.DevicePluginMissing");
                } else {
                    final String conTypeString =
                            ConnectionTypeConverter.convertCSVToPASW(row.get(CONNTYPE_ROW).getStringValue());
                    if (conTypeString == null) {
                        LOGGER.log(Level.WARNING, "Project.WrongConnectionType");
                    }
                    if (!dryRun) {
                        devInserter.insertDevice(device,
                                conTypeString,
                                devType,
                                row,
                                setTimeplanForAutoSync,
                                modbusTemplateConfig,
                                templateMap);
                    }
                }
            }
    }

    private static class DeviceInserter {

        private final List<IDeviceManager.AddDeviceHelper> m_DeviceList;
        private final List<IDeviceManager.AddDeviceHelper> m_ExistDevices;
        private final IDBDeviceManager m_DevMgr;
        private final ImportInformation m_ImportInfo;
        private final IFeatureProvider m_ProjFeature;

        private DeviceInserter(final List<IDeviceManager.AddDeviceHelper> deviceList,
                               final List<IDeviceManager.AddDeviceHelper> existDevicesList,
                               final IDBDeviceManager devMgr,
                               final ImportInformation importInfo,
                               final IFeatureProvider projFeature) {
            super();
            m_DeviceList = deviceList;
            m_ExistDevices = existDevicesList;
            m_DevMgr = devMgr;
            m_ImportInfo = importInfo;
            m_ProjFeature = projFeature;
        }

        private void insertDevice(final IDevice device,
                                  final String conTypeString,
                                  final String devType,
                                  final Row row,
                                  final boolean setTimeplanForAutoSync,
                                  ModbusTemplateConfig modbusTemplateConfig,
                                  HashMap<IDevice, String> templateMap
                                  ) {

            final DeviceInformation devInfo =
                    new DeviceInformation(Lookups.fixed(m_ProjFeature));
            devInfo.setType(devType);

            final Optional<String> devName = getParamString(row, DEVNAME_ROW);
            devName.ifPresent{devInfo.setName(it)};

            final Optional<String> devDesc = getParamString(row, DEVDESC_ROW);
            devDesc.ifPresent{devInfo.setDescription(it)};

            final String timeplanForAutoSync = getParamString(row, TIMEPLAN_ROW)
                    .map{timeplan -> (setTimeplanForAutoSync)
                            ? timeplan
                            : null}


            final Integer pollTime = getParamInt(row, POLLTIME_ROW).orElse(0);

            if (pollTime != null) {
                final IPollingTimeContainer pollIntvl =
                        device.getLookup().lookup(IPollingTimeContainer.class);
                pollIntvl.setPollingTimeConfig(PollingItem.DEFAULT, pollTime);
            }

            ConnectionTypes conType =
                    Optional.ofNullable(conTypeString)
                            .map({string -> ConnectionTypes.valueOf(string)}).orElse(ConnectionTypes.None);
            if (!device.getConnectionTypes().contains(conType)) {
                conType = ConnectionTypes.None;
            }
            final IConnectionType conTypeObj = device.getConnectionType(conType);

            conTypeObj.setConnectionString(row.get(CONN_ROW).getStringValue());
            device.setConnectionType(conTypeObj);

            devInfo.setConnectionString(String.format("%s:%s", conTypeString, row.get(CONN_ROW).getStringValue()));
            devInfo.setDevice(device);

            final boolean isGenericModbus = !DeviceFilterHelper.filterByUniqueName(DeviceFilter.GENERIC_MODBUS, devInfo);
            if (isGenericModbus) {
                getParamString(row, MODBUS_TEMPLATE_ROW).ifPresent({str ->
                    modbusTemplateConfig.getModbusTemplates().stream()
                            .filter({template -> str.equals(template.getName())})
                            .findAny()
                            .ifPresent({template ->
                                templateMap.put(device, str);
                            });
                });
            }

            final IDevice devfound = deviceExists(m_DevMgr, devInfo);
            if (devfound == null) {
                m_DeviceList.add(new IDeviceManager.AddDeviceHelper(devType,
                                                                    device,
                                                                    devName.orElse(null),
                                                                    devDesc.orElse(null),
                                                                    timeplanForAutoSync));
            } else {
                m_ExistDevices.add(
                        new IDeviceManager.AddDeviceHelper(devType,
                                                           devfound,
                                                           devName.orElse(null),
                                                           devDesc.orElse(null),
                                                           timeplanForAutoSync));
                m_ImportInfo.incSkippedDevices();
            }
        }

        private static Optional<String> getParamString(final Row row, final int index) {
            return Optional.ofNullable(row.getCellOrNull(index)?.getStringValue());
        }

        private static Optional<Integer> getParamInt(final Row row, final int index) {
            return Optional.ofNullable(Integer.parseInt(row.getCellOrNull(index).getStringValue()));
        }

        private static IDevice deviceExists(final IDBDeviceManager devMgr, final DeviceInformation devInfo) {
            IDevice result = null;
            final IConnectionType connType = devInfo.getDevice().getConnectionType();
            for (final DeviceInformation info : devMgr.getDevices()) {
                final IDevice dev = info.getDevice();
                if ((dev != null) && (!info.isDeleted())) {
                    final IConnectionType connType1 = dev.getConnectionType();
                    final boolean connTypeNone = connType instanceof IConnectionTypeNone;
                    final boolean connTypeNone1 = connType1 instanceof IConnectionTypeNone;

                    if (connTypeNone && connTypeNone1) {
                        /**
                         * always import device with connectiontype none
                         */
                        break;
                    } else if (!(connTypeNone || connTypeNone1) && (connType.equals(connType1))) {
                        /**
                         * device with same connectiontype and connectionparameters already present
                         */
                        result = dev;
                        break;
                    }
                }
            }
            return result;
        }
    }
}
